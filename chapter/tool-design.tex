\chapter{Tool Design}
\label{chp:tool-design}

Our tool aims to report compatibility issues induced by common types of breaking API changes via static analysis. Specifically, we designed it to fully automate the detection of API renaming/relocating and parameter renaming. It works in two phases: \textit{API Knowledge Base Extraction} and \textit{Issue Detection}. The first stage scans through the releases of a framework, extract all Python source files, and synthesizes a knowledge base that models the high-level changes of framework APIs. The second stage takes a client Python source file as input and seek and report potential compatibility issues based on the dataset's heuristic knowledges.

\section{GumTree}

GumTree is a source code differencing tool that has an AST-differencing algorithm at its core. It supports insertion, deletion, update, and move edit actions and computes a short edit script between two input source files, and present the changes close to programmers' intents in multiple forms. We use GumTree to analyze single Python source files in framework releases and deduce renamed APIs.

\section{API Extraction}

Given a set of library releases, our tool first extracts the APIs defined in Python source files in each release version, and classifies API changes into evolution patterns described in~\cite{DBLP:conf/wcre/ZhangZWTLX20}. In this part we pass the same Python source file in the latest release version and in an older version to GumTree, and detect matching APIs based on the edit script generated by GumTree.

\section{Edit Script Evaluation}

This part is yet to finish.

\section{Issue Detection}

After the first phase is accomplished and the knowledge base is constructed, the issue detection algorithm first retrieves the dependent framework release version used in the client project, then connects to the output of the API extraction program to access API change knowledges. The next step is to traverse through the Abstract Syntax Tree (AST) of the client Python source code and attain call sites of APIs defined in the framework, and determine the release version of the called API. With the dependency version and the version of API invoked, we could compute and analyze their differences and detect change patterns.
